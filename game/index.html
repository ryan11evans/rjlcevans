<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Frogger++ ‚Äî Smooth, Relaxed (seconds-based)</title>
<style>
  body{
    margin:0; padding:0; min-height:100vh;
    display:flex; align-items:center; justify-content:center;
    background:#eef2f7; font-family:system-ui,-apple-system,sans-serif;
  }
  #wrap{ text-align:center }
  h1{ margin:.2rem 0 .6rem; color:#444; font-size:1rem }
  canvas{ border:2px solid #333; background:#222; border-radius:8px; touch-action:none }
</style>
</head>
<body>
  <div id="wrap">
    <h1>üê∏ Frogger++ ‚Äî Smooth, Relaxed</h1>
    <canvas id="game" width="560" height="600"></canvas>
  </div>

<script>
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');

const TILE = 40;                 // 14 cols x 15 rows (560x600)
const COLS = cvs.width / TILE;   // 14
const ROWS = cvs.height / TILE;  // 15

// Relaxed pacing (affects all lanes equally)
const MOBILE = matchMedia('(max-width: 720px)').matches;
const SPEED_SCALE = MOBILE ? 0.55 : 0.6;  // gentle but clearly visible

// Rows (0 top): 0 goal, 1..5 WATER (logs/turtles), 6-7 grass, 8..12 ROAD (cars), 13 grass, 14 start
const GOAL_ROW = 0;
const WATER_START = 1, WATER_END = 5;
const ROAD_START = 8, ROAD_END = 12;
const START_POS = { x: Math.floor(COLS/2), y: ROWS-1 };

let frog = { x: START_POS.x, y: START_POS.y };

// ----- Lanes -----
const carLanes   = []; // cars
const floatLanes = []; // logs + turtles

// Helper: add lanes with velocities in *tiles per second* (not per frame)
function addCarLane(row, tilesPerSec, dir, color, density){
  const cars = [];
  const count = Math.max(2, Math.floor(COLS * density)); // at least 2 per lane
  for(let i=0;i<count;i++){
    const w = 1 + Math.floor(Math.random()*2); // 1-2 tiles
    const x = Math.random()*COLS;
    cars.push({ x, w });
  }
  carLanes.push({ row, v: tilesPerSec * SPEED_SCALE * dir, color, cars });
}

function addFloatLane(row, tilesPerSec, dir, color, density){
  const floats = [];
  const count = Math.max(2, Math.floor(COLS * density));
  for(let i=0;i<count;i++){
    const isTurtle = Math.random() < 0.3;               // 30% turtles
    const w = isTurtle ? (1 + Math.floor(Math.random()*2)) : (2 + Math.floor(Math.random()*3));
    const x = Math.random()*COLS;
    floats.push({ x, w, type: isTurtle ? 'turtle':'log', phase: Math.random()*Math.PI*2 });
  }
  floatLanes.push({ row, v: tilesPerSec * SPEED_SCALE * dir, color, floats });
}

// Tuned ‚Äúrelaxed but visible‚Äù base speeds (tiles/second BEFORE scale)
addFloatLane(1, 0.55, +1, '#8b5a2b', 0.18);
addFloatLane(2, 0.70, -1, '#8b5a2b', 0.16);
addFloatLane(3, 0.60, +1, '#8b5a2b', 0.18);
addFloatLane(4, 0.75, -1, '#8b5a2b', 0.16);
addFloatLane(5, 0.62, +1, '#8b5a2b', 0.18);

addCarLane(8,  0.50, +1, '#ef476f', 0.25);
addCarLane(9,  0.65, -1, '#ffd166', 0.22);
addCarLane(10, 0.55, +1, '#06d6a0', 0.24);
addCarLane(11, 0.70, -1, '#118ab2', 0.20);
addCarLane(12, 0.58, +1, '#8338ec', 0.22);

// ----- Draw helpers -----
function drawBackground(){
  for(let r=0;r<ROWS;r++){
    if(r===GOAL_ROW){
      ctx.fillStyle = '#2a9d8f';
    } else if(r>=WATER_START && r<=WATER_END){
      const g = ctx.createLinearGradient(0, r*TILE, 0, r*TILE+TILE);
      g.addColorStop(0, '#3a86ff'); g.addColorStop(1, '#2563eb');
      ctx.fillStyle = g;
    } else if(r>=ROAD_START && r<=ROAD_END){
      ctx.fillStyle = '#2b2b2b';
    } else {
      ctx.fillStyle = '#1d6b5f';
    }
    ctx.fillRect(0, r*TILE, cvs.width, TILE);

    if(r>=ROAD_START && r<=ROAD_END){
      ctx.strokeStyle='rgba(255,255,255,.15)';
      ctx.setLineDash([10,10]);
      ctx.beginPath();
      ctx.moveTo(0, r*TILE + TILE/2);
      ctx.lineTo(cvs.width, r*TILE + TILE/2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }
}

function drawCars(dtSec){
  carLanes.forEach(l=>{
    l.cars.forEach(c=>{
      c.x += l.v * dtSec;                 // tiles per second ‚Üí tiles moved this frame
      if(l.v > 0 && c.x > COLS + 2) c.x = -2;
      if(l.v < 0 && c.x < -2)       c.x = COLS + 2;
      ctx.fillStyle = l.color;
      ctx.fillRect(c.x*TILE, l.row*TILE+6, c.w*TILE-12, TILE-12);
      ctx.fillStyle = l.v>0 ? '#fff' : '#f00';
      ctx.fillRect(c.x*TILE + (l.v>0 ? c.w*TILE-18 : 6), l.row*TILE + TILE/2 - 3, 10, 6);
    });
  });
}

function drawFloats(dtSec, tMs){
  floatLanes.forEach(l=>{
    l.floats.forEach(f=>{
      f.x += l.v * dtSec;
      if(l.v > 0 && f.x > COLS + 4) f.x = -4;
      if(l.v < 0 && f.x < -4)       f.x = COLS + 4;
      const px = f.x*TILE, py = l.row*TILE+6, wpx = f.w*TILE-12;

      if(f.type==='log'){
        ctx.fillStyle = l.color;
        ctx.fillRect(px, py, wpx, TILE-12);
        ctx.strokeStyle = '#5b3a1a'; ctx.lineWidth = 2;
        ctx.strokeRect(px+2, py+2, wpx-4, TILE-16);
      } else {
        // turtles: round segments with gentle bob
        const bob = Math.sin((tMs/700)+f.phase)*2;
        for(let i=0;i<f.w;i++){
          ctx.fillStyle = '#0f766e';
          ctx.beginPath();
          ctx.arc(px + i*TILE + TILE/2, l.row*TILE + TILE/2 + bob, TILE*0.36, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#083e3b';
          ctx.beginPath();
          ctx.arc(px + i*TILE + TILE/2, l.row*TILE + TILE/2 + bob, TILE*0.28, 0, Math.PI*2);
          ctx.fill();
        }
      }
    });
  });
}

function drawFrog(){
  ctx.fillStyle = '#69e36e';
  ctx.beginPath();
  ctx.arc(frog.x*TILE + TILE/2, frog.y*TILE + TILE/2, TILE*0.35, 0, Math.PI*2);
  ctx.fill();
}

// ----- Input -----
function move(dir){
  if(dir==='up'   && frog.y>0)        frog.y--;
  if(dir==='down' && frog.y<ROWS-1)   frog.y++;
  if(dir==='left' && frog.x>0)        frog.x--;
  if(dir==='right'&& frog.x<COLS-1)   frog.x++;
}
document.addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(k==='arrowup'||k==='w')    move('up');
  if(k==='arrowdown'||k==='s')  move('down');
  if(k==='arrowleft'||k==='a')  move('left');
  if(k==='arrowright'||k==='d') move('right');
});
// swipe
let sx=0, sy=0;
cvs.addEventListener('touchstart', e=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
cvs.addEventListener('touchend', e=>{
  const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
  if(Math.abs(dx)>Math.abs(dy)){ if(dx>30) move('right'); else if(dx<-30) move('left'); }
  else { if(dy>30) move('down'); else if(dy<-30) move('up'); }
}, {passive:true});

// ----- Main loop (seconds-based) -----
let last = performance.now();
function loop(now){
  const dtSec = Math.min(0.05, (now - last)/1000); // clamp to avoid big jumps
  last = now;

  drawBackground();
  drawFloats(dtSec, now);
  drawCars(dtSec);
  drawFrog();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
