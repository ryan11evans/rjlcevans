<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Frogger++ (Casual Speed)</title>
  <style>
    :root { --ink:#1a1a1a; --muted:#555; }
    *{box-sizing:border-box}
    body{
      margin:0; padding:0;
      display:flex; align-items:center; justify-content:center;
      min-height:100vh; background:#eef2f7; color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #wrap{ text-align:center; padding:10px; position:relative }
    h1{ font-size:1.05rem; margin:.2rem 0 .6rem; color:var(--muted) }
    canvas{ border:2px solid #333; background:#222; border-radius:8px; touch-action:none }
    .hud{ margin:.4rem 0; font-weight:600 }
    .btns{ display:none; gap:.4rem; margin-top:.4rem; }
    .btns button{
      font-size:1rem; padding:.6rem .9rem; border-radius:10px; border:1px solid #ccc; background:#fff;
    }
    @media (max-width: 720px){
      .btns{ display:flex; flex-wrap:wrap; justify-content:center }
      .btns button{ min-width:96px }
    }
    /* Overlay */
    #overlay {
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55); border-radius:10px;
    }
    #overlay.show{ display:flex }
    .overlay-card{
      background:#ffffff; color:#111; padding:18px 22px; border-radius:12px; text-align:center;
      min-width: 260px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .overlay-card h2{ margin:6px 0 10px; font-size:1.25rem }
    .overlay-card p{ margin:0 0 14px; color:#444 }
    .overlay-card button{
      padding:.7rem 1.1rem; border-radius:10px; border:1px solid #ddd; background:#0ea5e9; color:#fff; font-weight:700;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <h1>Frogger++ ‚Äî casual speed (swipe or arrows)</h1>
    <canvas id="game" width="560" height="600"></canvas>
    <div class="hud"><span id="lives">Lives: 3</span> ¬∑ <span id="score">Score: 0</span></div>
    <div class="btns">
      <button data-d="up">‚Üë Up</button>
      <button data-d="left">‚Üê Left</button>
      <button data-d="down">‚Üì Down</button>
      <button data-d="right">‚Üí Right</button>
      <button id="restart">‚ü≤ Restart</button>
    </div>

    <div id="overlay">
      <div class="overlay-card">
        <h2 id="ov-title">Game Over üíÄ</h2>
        <p id="ov-sub">Score: <span id="ov-score">0</span></p>
        <button id="ov-btn">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    const cvs = document.getElementById('game'); const ctx = cvs.getContext('2d');
    const TILE = 40; // 14 cols x 15 rows (560x600)
    const COLS = cvs.width / TILE;
    const ROWS = cvs.height / TILE;

    // Rows (0 top): 0 goal, 1-5 WATER (logs/turtles), 6-7 grass, 8-12 ROAD (cars), 13 grass, 14 start
    const GOAL_ROW = 0;
    const WATER_START = 1, WATER_END = 5;
    const ROAD_START = 8, ROAD_END = 12;
    const START_POS = { x: Math.floor(COLS/2), y: ROWS-1 };

    // Casual speed scaling (mobile slightly slower)
    const MOBILE = window.matchMedia('(max-width: 720px)').matches;
    const GLOBAL_SPEED = MOBILE ? 0.7 : 0.8; // overall gentle pacing

    // State
    let frog = { x: START_POS.x, y: START_POS.y, subPixelX: 0, dying:false };
    let lives = 3, score = 0, gameOver = false;
    const goals = Array(COLS).fill(false);

    // Lanes
    const carLanes = [];
    const floatLanes = []; // logs + turtles

    function addCarLane(row, baseSpeed, dir, color, density){
      const cars = [];
      const count = Math.floor(COLS * density);
      for(let i=0;i<count;i++){
        const w = 1 + Math.floor(Math.random()*2); // 1-2 tiles
        const x = Math.floor(Math.random()*COLS);
        cars.push({ x, w });
      }
      carLanes.push({ row, speed: baseSpeed * GLOBAL_SPEED, dir, color, cars });
    }

    function addFloatLane(row, baseSpeed, dir, color, density){
      const floats = [];
      const count = Math.floor(COLS * density);
      for(let i=0;i<count;i++){
        if(Math.random() < 0.7){
          const w = 2 + Math.floor(Math.random()*3); // 2-4 tiles logs
          const x = Math.floor(Math.random()*COLS);
          floats.push({ type:'log', x, w });
        } else {
          const w = 1 + Math.floor(Math.random()*2); // 1-2 tiles turtles
          const x = Math.floor(Math.random()*COLS);
          floats.push({ type:'turtle', x, w, bobPhase: Math.random()*Math.PI*2 });
        }
      }
      floatLanes.push({ row, speed: baseSpeed * GLOBAL_SPEED, dir, color, floats });
    }

    // Build lanes with slower base speeds
    // Water lanes (reduced ~45% vs earlier): 0.38, 0.55, 0.45, 0.66, 0.50
    addFloatLane(1,  0.38,  1, '#8b5a2b', 0.18);
    addFloatLane(2,  0.55, -1, '#8b5a2b', 0.16);
    addFloatLane(3,  0.45,  1, '#8b5a2b', 0.18);
    addFloatLane(4,  0.66, -1, '#8b5a2b', 0.16);
    addFloatLane(5,  0.50,  1, '#8b5a2b', 0.18);

    // Road lanes (reduced ~40%): 0.45, 0.60, 0.50, 0.70, 0.55
    addCarLane(8,  0.45,  1, '#ef476f', 0.25);
    addCarLane(9,  0.60, -1, '#ffd166', 0.22);
    addCarLane(10, 0.50,  1, '#06d6a0', 0.24);
    addCarLane(11, 0.70, -1, '#118ab2', 0.20);
    addCarLane(12, 0.55,  1, '#8338ec', 0.22);

    function resetFrog(){
      frog.x = START_POS.x; frog.y = START_POS.y; frog.subPixelX = 0; frog.dying=false;
    }

    // Drawing
    function drawBackground(){
      for(let r=0;r<ROWS;r++){
        if(r===GOAL_ROW){
          ctx.fillStyle = '#2a9d8f';
        } else if(r>=WATER_START && r<=WATER_END){
          const g = ctx.createLinearGradient(0, r*TILE, 0, r*TILE+TILE);
          g.addColorStop(0, '#3a86ff'); g.addColorStop(1, '#2563eb');
          ctx.fillStyle = g;
        } else if(r>=ROAD_START && r<=ROAD_END){
          ctx.fillStyle = '#2b2b2b';
        } else {
          ctx.fillStyle = '#1d6b5f';
        }
        ctx.fillRect(0, r*TILE, cvs.width, TILE);

        if(r>=ROAD_START && r<=ROAD_END){
          ctx.strokeStyle='rgba(255,255,255,.15)';
          ctx.setLineDash([10,10]);
          ctx.beginPath();
          ctx.moveTo(0, r*TILE + TILE/2);
          ctx.lineTo(cvs.width, r*TILE + TILE/2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      // goal slots indicators
      ctx.fillStyle='rgba(255,255,255,.25)';
      for(let c=0;c<COLS;c++){
        if(goals[c]){
          ctx.fillStyle='rgba(255,255,255,.55)';
          ctx.fillRect(c*TILE+8, 4, TILE-16, TILE-8);
          ctx.fillStyle='rgba(255,255,255,.25)';
        }else{
          ctx.fillRect(c*TILE+16, 8, TILE-32, TILE-16);
        }
      }
    }

    function drawCars(dt){
      carLanes.forEach(l => {
        l.cars.forEach(car => {
          car.x += l.dir * l.speed * dt;
          if(l.dir===1 && car.x > COLS+2) car.x = -2;
          if(l.dir===-1 && car.x < -2) car.x = COLS+2;
          const px = Math.round(car.x*TILE);
          ctx.fillStyle = l.color;
          ctx.fillRect(px, l.row*TILE+6, car.w*TILE-12, TILE-12);
          ctx.fillStyle = l.dir===1 ? '#fff' : '#f00';
          ctx.fillRect(px + (l.dir===1 ? car.w*TILE-18 : 6), l.row*TILE+TILE/2-3, 10, 6);
        });
      });
    }

    function drawFloats(dt, t){
      floatLanes.forEach(l => {
        l.floats.forEach(f => {
          f.x += l.dir * l.speed * dt;
          if(l.dir===1 && f.x > COLS+4) f.x = -4;
          if(l.dir===-1 && f.x < -4) f.x = COLS+4;
          const px = Math.round(f.x*TILE);
          if(f.type==='log'){
            ctx.fillStyle = l.color;
            ctx.fillRect(px, l.row*TILE+6, f.w*TILE-12, TILE-12);
            ctx.strokeStyle = '#5b3a1a';
            ctx.lineWidth = 2;
            ctx.strokeRect(px+2, l.row*TILE+8, f.w*TILE-16, TILE-16);
          } else {
            // turtle: draw as circles with subtle bobbing
            const bob = Math.sin((t/600) + f.bobPhase) * 1.8; // slower bob
            for(let i=0;i<f.w;i++){
              ctx.fillStyle = '#0f766e';
              ctx.beginPath();
              ctx.arc(px + i*TILE + TILE/2, l.row*TILE + TILE/2 + bob, TILE*0.36, 0, Math.PI*2);
              ctx.fill();
              ctx.fillStyle = '#083e3b';
              ctx.beginPath();
              ctx.arc(px + i*TILE + TILE/2, l.row*TILE + TILE/2 + bob, TILE*0.28, 0, Math.PI*2);
              ctx.fill();
            }
          }
        });
      });
    }

    function floatSupport(){
      if(frog.y < WATER_START || frog.y > WATER_END) return { on:false, drift:0 };
      const lane = floatLanes.find(l=>l.row===frog.y);
      if(!lane) return { on:false, drift:0 };
      for(const f of lane.floats){
        if(frog.x >= f.x && frog.x < f.x + f.w){
          return { on:true, drift: lane.dir * lane.speed };
        }
      }
      return { on:false, drift:0 };
    }

    function carHit(){
      if(frog.y < ROAD_START || frog.y > ROAD_END) return false;
      const lane = carLanes.find(l=>l.row===frog.y);
      if(!lane) return false;
      for(const car of lane.cars){
        if(frog.x < car.x + car.w && frog.x + 1 > car.x) return true;
      }
      return false;
    }

    function drawFrog(){
      const fx = frog.x*TILE + frog.subPixelX + TILE/2;
      const fy = frog.y*TILE + TILE/2;
      ctx.fillStyle = frog.dying ? '#b22222' : '#69e36e';
      ctx.beginPath(); ctx.arc(fx, fy, TILE*0.35, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0b3d0b';
      ctx.beginPath();
      ctx.arc(fx - TILE*0.15, fy - TILE*0.12, 4, 0, Math.PI*2);
      ctx.arc(fx + TILE*0.15, fy - TILE*0.12, 4, 0, Math.PI*2);
      ctx.fill();
    }

    function stepToGoal(){
      if(frog.y === GOAL_ROW){
        if(!goals[Math.round(frog.x)]){
          goals[Math.round(frog.x)] = true;
          score += 100;
        } else {
          score += 25;
        }
        document.getElementById('score').textContent = 'Score: ' + score;
        resetFrog();
        const filled = goals.filter(Boolean).length;
        if(filled >= Math.ceil(COLS*0.5)){
          endGame(true);
        }
      }
    }

    function showOverlay(title, sc){
      document.getElementById('ov-title').textContent = title;
      document.getElementById('ov-score').textContent = sc;
      document.getElementById('overlay').classList.add('show');
    }
    function hideOverlay(){ document.getElementById('overlay').classList.remove('show'); }

    function endGame(win){
      gameOver = true;
      showOverlay(win ? 'You Win! üéâ' : 'Game Over üíÄ', score);
    }

    function restart(){
      hideOverlay();
      lives = 3; score = 0; gameOver = false;
      for(let i=0;i<COLS;i++) goals[i]=false;
      resetFrog();
      document.getElementById('lives').textContent = 'Lives: ' + lives;
      document.getElementById('score').textContent = 'Score: ' + score;
      requestAnimationFrame(loop);
    }

    function move(dir){
      if(gameOver) return;
      if(dir==='up'   && frog.y>0) frog.y--;
      if(dir==='down' && frog.y<ROWS-1) frog.y++;
      if(dir==='left' && frog.x>0) frog.x--;
      if(dir==='right'&& frog.x<COLS-1) frog.x++;
      frog.subPixelX = 0;
      stepToGoal();
    }

    // Keyboard
    document.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();
      if(k===' '){ if(gameOver){ restart(); return; } }
      if(k==='arrowup' || k==='w') move('up');
      if(k==='arrowdown'|| k==='s') move('down');
      if(k==='arrowleft'|| k==='a') move('left');
      if(k==='arrowright'||k==='d') move('right');
    });

    // Touch swipe
    let touchStart = null;
    function handleStart(e){ touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
    function handleEnd(e){
      if(!touchStart) return;
      const dx = (e.changedTouches[0].clientX - touchStart.x);
      const dy = (e.changedTouches[0].clientY - touchStart.y);
      const adx = Math.abs(dx), ady = Math.abs(dy);
      if(Math.max(adx, ady) < 28) { touchStart = null; return; } // slightly higher threshold
      if(adx > ady){ move(dx>0 ? 'right' : 'left'); } else { move(dy>0 ? 'down' : 'up'); }
      touchStart = null;
    }
    cvs.addEventListener('touchstart', handleStart, {passive:true});
    cvs.addEventListener('touchend', handleEnd, {passive:true});

    // Buttons & overlay
    document.querySelectorAll('.btns button[data-d]').forEach(b=> b.addEventListener('click', ()=> move(b.dataset.d)));
    document.getElementById('restart').addEventListener('click', restart);
    document.getElementById('ov-btn').addEventListener('click', restart);

    // Main loop
    let last = performance.now();
    function loop(t){
      const dt = Math.min(32, (t - last)) / 16.6667; // normalize to ~60fps
      last = t;

      drawBackground();
      drawFloats(dt, t);

      // Water logic
      if(frog.y>=WATER_START && frog.y<=WATER_END){
        const sup = floatSupport();
        if(sup.on){
          frog.subPixelX += sup.drift * dt * TILE;
          if(Math.abs(frog.subPixelX) >= TILE){
            frog.x += Math.sign(frog.subPixelX);
            frog.subPixelX = 0;
          }
          if(frog.x < 0 || frog.x >= COLS){
            lives -= 1; document.getElementById('lives').textContent = 'Lives: ' + lives;
            if(lives<=0){ endGame(false); return; }
            resetFrog();
          }
        } else {
          lives -= 1; document.getElementById('lives').textContent = 'Lives: ' + lives;
          if(lives<=0){ endGame(false); return; }
          resetFrog();
        }
      }

      drawCars(dt);

      if(carHit()){
        lives -= 1; document.getElementById('lives').textContent = 'Lives: ' + lives;
        if(lives<=0){ endGame(false); return; }
        resetFrog();
      }

      drawFrog();

      if(!gameOver) requestAnimationFrame(loop);
    }

    restart();
  </script>
</body>
</html>
