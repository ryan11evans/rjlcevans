import pygame
import sys

# Initialize Pygame
pygame.init()

# Constants
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BLUE = (135, 206, 235)  # Sky blue
GREEN = (34, 139, 34)   # Forest green
BROWN = (139, 69, 19)   # Saddle brown for ground
YELLOW = (255, 255, 0)  # Yellow for dog
RED = (255, 0, 0)       # Red for bats
GRAY = (128, 128, 128)  # Gray for blocks

# Game setup
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Happy Dog Adventure")
clock = pygame.time.Clock()

# Player (Happy Dog) class
class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((40, 40))
        self.image.fill(YELLOW)
        # Simple dog face: eyes and mouth
        pygame.draw.circle(self.image, BLACK, (10, 15), 3)  # Left eye
        pygame.draw.circle(self.image, BLACK, (30, 15), 3)  # Right eye
        pygame.draw.arc(self.image, BLACK, (10, 20, 20, 10), 0, 3.14, 2)  # Smile
        self.rect = self.image.get_rect()
        self.rect.x = 50
        self.rect.y = SCREEN_HEIGHT - 100
        self.vel_x = 0
        self.vel_y = 0
        self.on_ground = False
        self.jumping = False

    def update(self, platforms, enemies):
        # Horizontal movement
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]:
            self.vel_x = -5
        elif keys[pygame.K_RIGHT]:
            self.vel_x = 5
        else:
            self.vel_x = 0

        # Jumping
        if keys[pygame.K_SPACE] and self.on_ground:
            self.vel_y = -15
            self.on_ground = False
            self.jumping = True

        # Apply gravity
        self.vel_y += 0.8  # Gravity

        # Horizontal collision
        self.rect.x += self.vel_x
        for platform in platforms:
            if self.rect.colliderect(platform.rect):
                if self.vel_x > 0:
                    self.rect.right = platform.rect.left
                elif self.vel_x < 0:
                    self.rect.left = platform.rect.right

        # Vertical collision
        self.rect.y += self.vel_y
        self.on_ground = False
        for platform in platforms:
            if self.rect.colliderect(platform.rect):
                if self.vel_y > 0:
                    self.rect.bottom = platform.rect.top
                    self.on_ground = True
                    self.jumping = False
                    self.vel_y = 0
                elif self.vel_y < 0:
                    self.rect.top = platform.rect.bottom
                    self.vel_y = 0

        # Enemy collision
        for enemy in enemies:
            if self.rect.colliderect(enemy.rect):
                if self.vel_y > 0 and self.rect.bottom < enemy.rect.centery:  # Jumping on enemy
                    enemy.kill()
                    self.vel_y = -10  # Bounce
                else:
                    # Game over or reset
                    self.rect.x = 50
                    self.rect.y = SCREEN_HEIGHT - 100
                    self.vel_x = 0
                    self.vel_y = 0

    def draw(self, screen):
        screen.blit(self.image, self.rect)

# Platform/Block class
class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, color=GRAY):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

    def draw(self, screen):
        screen.blit(self.image, self.rect)

# Pipe class (simple green platform-like)
class Pipe(Platform):
    def __init__(self, x, y):
        super().__init__(x, y, 60, 100, GREEN)

# Enemy (Bat) class
class Enemy(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((30, 20))
        self.image.fill(RED)
        # Simple bat wings
        pygame.draw.polygon(self.image, BLACK, [(0, 0), (10, 10), (0, 20)])
        pygame.draw.polygon(self.image, BLACK, [(30, 0), (20, 10), (30, 20)])
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel_x = -2  # Moving left

    def update(self, platforms):
        self.rect.x += self.vel_x
        # Reverse direction on platform edge (simple AI)
        on_platform = False
        for platform in platforms:
            if self.rect.colliderect(platform.rect):
                on_platform = True
                break
        if not on_platform or self.rect.left < 0 or self.rect.right > SCREEN_WIDTH:
            self.vel_x *= -1

    def draw(self, screen):
        screen.blit(self.image, self.rect)

# Main game function
def main():
    player = Player()
    all_sprites = pygame.sprite.Group()
    all_sprites.add(player)

    # Platforms (ground and blocks)
    platforms = pygame.sprite.Group()
    ground = Platform(0, SCREEN_HEIGHT - 50, SCREEN_WIDTH, 50, BROWN)
    platforms.add(ground)
    block1 = Platform(200, SCREEN_HEIGHT - 150, 50, 50)
    platforms.add(block1)
    block2 = Platform(400, SCREEN_HEIGHT - 200, 50, 50)
    platforms.add(block2)
    pipe1 = Pipe(600, SCREEN_HEIGHT - 150)
    platforms.add(pipe1)

    # Enemies (bats)
    enemies = pygame.sprite.Group()
    bat1 = Enemy(300, SCREEN_HEIGHT - 200)
    enemies.add(bat1)
    bat2 = Enemy(500, SCREEN_HEIGHT - 250)
    enemies.add(bat2)

    running = True
    while running:
        clock.tick(FPS)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Updates
        player.update(platforms, enemies)
        for enemy in enemies:
            enemy.update(platforms)

        # Draw
        screen.fill(BLUE)
        for platform in platforms:
            platform.draw(screen)
        player.draw(screen)
        for enemy in enemies:
            enemy.draw(screen)

        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
